#!/usr/bin/env node

'use strict';

let fs = require('fs')
let spawn = require('child_process').spawn
let os = require('os')

let _ = require('lodash')
let chokidar = require('chokidar')
let minimist = require('minimist')

let meta = require('./package.json')

let log = console.error.bind(console, `${meta.name}:`)

let vlog = () => {}

class NEId {
    constructor() {
	this.counter = 0
    }

    get() {
	return this.counter++
    }
}

class NotifyEvent {
    constructor(neid, event, file) {
	this.id = neid.get()
	this.event = event
	this.file = file
    }

    toString() {
	return [this.id, this.event, this.file].join(' ')
    }
}

let tidings = function(cmd, state, ne, force = false) {
    if (state.locked) {
	vlog(`${ne}: LOCKED`)
	state.solicitor = ne
	return
    }

    vlog(`${ne}: RUN "${cmd.name}"` + (force ? ' again' : ''))

    state.solicitor = null
    state.locked = true
    let child = spawn(cmd.name, cmd.args,
		      { stdio: ['inherit', 'inherit', 'inherit'] })

    child.on('exit', (code) => {
	state.locked = false
	if (code !== 0) log(`${ne.id}: ${cmd.name} exited w/ ${code}`)
	if (state.solicitor) tidings(cmd, state, state.solicitor, true)
    })

    child.on('error', (err) => {
	state.locked = false
	log(`${ne.id}: ${cmd.name}: ${err}`)
	if (state.solicitor) tidings(cmd, state, state.solicitor, true)
    })
}

let watch = function(conf) {
    let state = {
	locked: false,
	solicitor: null,
	last: null
    }

    let debounce_tidings = _.debounce(function(o, s, c) {
	tidings(o, s, c)
    }, conf.opt.debounce)

    let neid = new NEId()
    let watcher = chokidar.watch(conf.opt.a, {ignored: conf.exclude})

    watcher.on('all', (event, file) => {
	let cur = new NotifyEvent(neid, event, file)
	debounce_tidings(conf.cmd, state, cur)
	state.last = cur
    })

    watcher.on('error', err => {
	console.error(err.toString())
	if (err.code === 'ENOSPC' && os.platform() === 'linux') {
	    console.error(`
This usually means you've reached the max number of the inotify watches.
See /proc/sys/fs/inotify/max_user_watches for the current value.
We've defaulted on ${state.last.id+1}.`)
	}
	process.exit(1)
    })
}


// Main
let argv = minimist(process.argv.slice(2), {
    default: {
	a: '.',
	debounce: 1000,
	e: [],
	v: false,
    },
    boolean: ['v'],
    string: ['a']
})

let conf = {
    exclude: _.uniq(['.*~', '*~', '.#*', '*.lock', '*.lock-*', '*.pid',
		     'node_modules', 'npm-debug.log', '.git', '.ph']
		    .concat(argv.e)),
    opt: argv,
    cmd: {
	name: argv._[0],
	args: argv._.slice(1)
    },
}

conf.opt.a = [].concat(conf.opt.a)
if (!conf.cmd.name) {
    conf.cmd.name = 'fortune'
    conf.cmd.args = ['-n', '80', '-s']
}
if (conf.opt.v) vlog = log

vlog(conf)
try {
    // actually, it should be chokidar's job
    conf.opt.a.forEach( dir => fs.statSync(dir) )
} catch (err) {
    console.error(err.toString())
    process.exit(1)
}
watch(conf)
